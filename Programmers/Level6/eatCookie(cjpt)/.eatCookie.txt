Question. 과자 많이 먹기 --> https://programmers.co.kr/learn/challenge_codes/59

python
dfs로 풀이할 수 있었다.
다른사람 풀이의 변수명을 보니 dp로도 풀 수 있는 것 같다.
문제 분할 문제는 대부분 dp로 치환이 가능하다는 생각이 들었다.

우선 dp로 한번 풀어보고 다른 사람의 풀이를 추가할 생각이다.

1.
def eatCookie(cookies):
    n=len(cookies)
    dp=[0 for _ in range(n)]
    dp[0]=1
    mcnt=0
    for i in range(1,n):
        m=0
        for j in range(i):
            if cookies[i]>cookies[j]:
                if m<dp[j]:
                    m=dp[j]
        dp[i]=m+1
    return max(dp)
# 아래는 테스트로 출력해 보기 위한 코드입니다.
print(eatCookie([1, 4, 2, 6, 3, 4, 1, 5]))

훌륭한 dp. 전형적이면서 깔끔하다.
어떤 데이터를 현재에 적용할 수 있을 것인가를 생각해보면 풀이방식이 쉽다.



2.
def eatCookie(cookies):
    array = [[cookies[-1]]]
    for cookie in cookies[:-1][::-1]:
        for i in range(len(array)):
            if array[i][0] > cookie:
                array.append([cookie] + array[i])
        array.append([cookie])
    max_num = 0
    for arr in array:
        max_num = max(max_num, len(arr))
    return max_num

dp를 생각했을 때 떠올린 아이디어와 비슷한 것 같다. 피곤한 관계로 머리가 돌지 않는다.
잠시 유보해 두고 위의 방식의 dp먼저 진행하고 나중에 다시 해볼 생각이다.

분석완료
모든 경우의 수를 다 만드는 형태. 뒤에서부터 배열을 자라게 하는 모양새이다.





Java
1.
import java.util.Arrays;

class EatCookie
{
    public int eatCookie(int []cookies){
        int[] dp = new int[cookies.length];
        int len = 0;

        for(int x : cookies) {
            int i = Arrays.binarySearch(dp, 0, len, x);
            if(i < 0) i = -(i + 1);
            dp[i] = x;
            if(i == len) len++;
        }

        return len;
    }

BinarySearch를 이용한 풀이 매우 신선하다.
BinarySearch(int[] arr, int fromIndex, int toIndex, byte key)는
찾는 데이터가 있는 경우에는 해당 위치의 인덱스를 반환하고
찾는 데이터가 없는 경우에는 (-insertion point-1)을 반환한다.
insertion point는 찾는 값보다 처음으로 큰 값이 나타나는 위치,
모든 값이 키보다 작을 경우에는 toIndex의 위치를 반환한다.


예제를 바탕으로 데이터를 풀어보았다. 신기하게도 최적의 방식으로 배열이 세팅되는 것을 확인할 수 있었다.

다소 피곤해서 완벽한 분석은 불가능할 것 같다. C++로 재귀방식으로 한번더 풀고 재도전하겠다.