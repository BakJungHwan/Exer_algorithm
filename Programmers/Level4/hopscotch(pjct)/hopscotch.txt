Question. 땅따먹기 게임 -> https://programmers.co.kr/learn/challenge_codes/35/solutions


Python
1.
def hopscotch(board, size):
    result = 0
    # 땅따먹기 게임으로 얻을 수 있는 최대 점수는?
    for i in range(1,size):
        for j in range(4):
            temp = copy.deepcopy(board[i-1])
            temp[j] = 0
            board[i][j]+=max(temp)
    result = max(board[-1])
    return result

dfs가 떠오르는 문제인데, 첫번째 인상적인 답이 동적계획법에 가까웠다.
매번 deepcopy를 하는 것외에는 맘에 들었다.
temp[j]에 0을 대입해서 최대값이 아니도록 하는 아이디어가 맘에 들었다.
deepcopy는 0을 대입하고 최신화하기 위해 실행하는 것으로, 알고리즘의 핵심은 아니다.




2.
def hopscotch(board, size):
    accum = [0] * len(board[0])

    for row in board:
        tmp = accum[:]
        for i in range(len(row)):
            accum[i] = row[i] + max(tmp[:i] + tmp[i+1:])

    return max(accum)

동적계획법 형태로 설계. 누적값 중에 현재 선택하지 않은 자리에 있는 녀석들의 최대값을 뽑아서 계산
도전해볼만한 방법
Java와 C++로 본능적으로 구현하기에 용이했다.



3.
def hopscotch(board, size):
    a,b,c,d = 0,0,0,0

    def get(v,x,y,z):
        return v+max(x,y,z);

    for _a,_b,_c,_d in board:
        a,b,c,d = get(_a,b,c,d), get(_b,a,c,d), get(_c,a,b,d), get(_d,a,b,c)

    return max(a,b,c,d)

이 녀석도 새로운 접근이다. 누적값의 최대값의 위치를 뽑아내는 것.
지금까지는 가장 맘에 든다.
a,b,c,d는 누적값을 저장하는 변수들이다.




C++
1.
int hopscotch(vector<vector<int> > board)
{
    int max_1; int max_2;
    int max_index;
    for (int i = 0; i < board.size() - 1; i++) {
        max_1 = 0;
        max_2 = 0;
        for (int j = 0; j < board[i].size(); j++) {
            if (board[i][j] > max_1) {
                max_2 = max_1;
                max_1 = board[i][j];
                max_index = j;
            }
            else if (board[i][j] > max_2)
                max_2 = board[i][j];
        }
        for (int j = 0; j < board[i].size(); j++) {
            if (j != max_index)
                board[i + 1][j] += max_1;
            else
                board[i + 1][j] += max_2;
        }

    }
    max_1 = 0;
    for (int i = 0; i < 4; i++)
        if (board[board.size() - 1][i] > max_1)
            max_1 = board[board.size() - 1][i];
    return max_1;

센스있는 코드. 첫번째로 큰 숫자가 아니면 두번째 큰숫자를 더하는 방법이 있다.



2.


3.
int find(vector<vector<int>> board, int n/*전 위치*/, int x)
{
    int ret=0;
    if (x == board.size()) return 0;
    if (n == 0) ret += board[x][n] + max(find(board, 1, x + 1), max(find(board, 2, x + 1), find(board, 3, x + 1)));
    if (n == 1) ret += board[x][n] + max(find(board, 0, x + 1), max(find(board, 2, x + 1), find(board, 3, x + 1)));
    if (n == 2) ret += board[x][n] + max(find(board, 1, x + 1), max(find(board, 0, x + 1), find(board, 3, x + 1)));
    if (n == 3) ret += board[x][n] + max(find(board, 1, x + 1), max(find(board, 2, x + 1), find(board, 0, x + 1)));

    return ret;
}

Java에서도 나왔던 형태, 아주 명백하다.